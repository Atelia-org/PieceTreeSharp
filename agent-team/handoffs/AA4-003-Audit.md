# AA4-003 – CL7 Cursor Word/Snippet/Multi-Selection Audit

## Overview
CL7 covers cursor word navigation, snippet tab stop handling, and multi-selection parity for AA4 Sprint 02 (`docs/sprints/sprint-02.md`, `agent-team/task-board.md`). This audit compares the VS Code TS stack (`ts/src/vs/editor/common/cursor/*`, `ts/src/vs/editor/contrib/snippet/browser/snippetController2.ts`) with the current C# port (`src/PieceTree.TextBuffer/Cursor`, `src/PieceTree.TextBuffer/TextModel.cs`, `src/PieceTree.TextBuffer/Rendering/MarkdownRenderer.cs`) and records the gaps required before Porter-CS can implement AA4-007 fixes. Checklist anchor: `docs/reports/audit-checklist-aa4.md#cl7`.

## Findings
| # | Severity | Focus | TS Reference | C# Gap | Details & Proposed Fix Notes | Blocking Risk |
| --- | --- | --- | --- | --- | --- | --- |
| F1 | High | Multi-cursor controller & state recovery | `cursor.ts`, `cursorCollection.ts`, `cursorContext.ts`, `cursorCommon.ts` | `Cursor/Cursor.cs`, `TextModel.cs`, `Rendering/MarkdownRenderer.cs` | TS keeps a `CursorsController` backed by `CursorCollection`, per-cursor model/view states, column-select metadata, injected-text aware recovery, multi-c limits, and normalization of overlapping selections. The C# port only exposes a single `Cursor` that stores one `Selection`, never subscribes to `TextModel.OnDidChangeContent`, never tracks `ICursorSimpleModel` contexts, and therefore never emits additional cursor decorations for DocUI (`MarkdownRenderer` only sees a single cursor/selection owner). **Action:** Port `CursorContext`, `CursorState`, `CursorCollection`, `CursorChangeReason`, hooking them into `TextModel` events and ensuring `MarkdownRenderer` renders each cursor/selection pair. | Multi-selection commands (Ctrl+D, Alt+Click, injected text adjustments) remain impossible and DocUI cannot render parity output. |
| F2 | High | Word navigation & word-part heuristics | `cursorWordOperations.ts`, `cursorMoveOperations.ts`, `cursorCommon.ts` (`wordSeparators`) | `Cursor/Cursor.cs` (no word APIs), `PieceTree.TextBuffer.Core` (no `WordCharacterClassifier`) | TS exposes `WordOperations.moveWordLeft/Right`, `wordPartLeft/Right`, delete-word variants, `WordNavigationType` (standard vs accessibility), and uses `WordCharacterClassifier` + `Intl.Segmenter` to honor locale-specific word boundaries. The C# port only supports single-character `MoveLeft/Right/Up/Down`, lacks any word separator classifier, and cannot expose Ctrl+Arrow navigation, selection, or delete semantics. **Action:** Introduce a `WordCharacterClassifier` equivalent, port `WordOperations` + `WordNavigationType`, and thread `wordSeparators` & locale data from `TextModelOptions` into the cursor layer so command handlers (and eventually DocUI macros) can call into consistent word/wordPart logic. | Word-wise movement, selection, delete, and snippet placeholder expansion cannot match VS Code, blocking CL7 scope entirely. |
| F3 | Medium-High | Column selection & visible-column tracking | `cursorColumnSelection.ts`, `cursorCommon.ts` (`columnFromVisibleColumn`, `SelectionStartKind`), `cursorMoveOperations.ts` (vertical move, sticky tab stops) | `Cursor/Cursor.cs`, `TextModel.cs` | TS maintains `IColumnSelectData`, `SelectionStartKind`, leftover visible columns, and relies on model helpers (`getLineMin/MaxColumn`, `getLineFirst/LastNonWhitespaceColumn`, `getLineIndentColumn`, `normalizePosition`) to implement Alt+drag block selection and consistent vertical moves across tabs/injected text. C# currently lacks every required helper—`TextModel` exposes only `GetLineContent/MaxColumn`, `Cursor` stores no leftover column metadata, and there is no `CursorConfiguration` to convert visible↔real columns. **Action:** Add the missing line helpers to `TextModel`/`PieceTreeBuffer`, port `CursorConfiguration`+`CursorColumns`, implement `ColumnSelection` and vertical move logic, and persist `_columnSelectData` on the cursor controller. | Column/block selection, multi-cursor copy/paste, and sticky tab-stop navigation cannot be implemented or tested, leaving DocUI without parity scenarios. |
| F4 | High | Snippet session & tabstop stickiness | `snippetController2.ts`, `snippetSession.ts`, cursor integration hooks | *(none in C#; `Cursor.cs` only has a TODO)* | TS wires `SnippetController2` into the editor, managing `SnippetSession` state, undo-stop boundaries, placeholder decorations, choice completions, and integration with cursor selections (one snippet session can manage many cursors). The C# stack has no snippet session/controller, no placeholder tracking, no context keys, and `Cursor.cs` merely logs a TODO where snippet tabstop stickiness should plug in. MarkdownRenderer similarly cannot render snippet placeholders because no owner IDs/decorations are reserved. **Action:** Port `SnippetSession` + `SnippetController2`, expose snippet insertion APIs over `TextModel` (`PushStackElement`, `TextModelEditSource` already exist), attach to the multi-cursor controller, and emit placeholder decorations that MarkdownRenderer can visualize. | Snippet insertion/tabstop navigation (part of CL7 scope) is impossible; Porter-CS cannot implement AA4-007 fixes without a controller surface. |

## Proposed Fix Themes
1. **Recreate the cursor infrastructure** (`CursorContext`, `CursorCollection`, `CursorState`/`PartialCursorState`, `CursorChangeReason`, `ICursorSimpleModel`) and hook it into `TextModel` events plus DocUI decoration owners so multiple cursors/selections can exist.
2. **Port word-aware movement APIs** by introducing `WordCharacterClassifier`, `WordNavigationType`, and the full `WordOperations` surface (word start, word end, wordPart, delete and select variants) backed by TS-equivalent heuristics and locale data.
3. **Add column-selection & vertical movement primitives**: extend `TextModel` with `GetLineMinColumn`, `GetLineFirst/LastNonWhitespaceColumn`, `GetLineIndentColumn`, `NormalizePosition`; port `CursorColumns` helpers + `ColumnSelection` pipeline; persist `_columnSelectData` and leftover visible columns.
4. **Implement snippet sessions** (`SnippetSession`, controller, placeholder decorations, choice completions) tied to cursor state and undo stack, and surface snippet owner IDs to DocUI/MarkdownRenderer.

## Validation Hooks / Tests to Add
- `CursorMultiSelectionTests.MultiCursorLifecycle` – verifies creating, merging, and recovering multiple cursors across edits/injected text plus MarkdownRenderer output of multiple `|`/`[]` markers.
- `CursorWordOperationsTests.WordNavigationParity` – covers `WordStart`, `WordEnd`, `WordAccessibility`, `wordPart`, and delete-word commands using sample text that exercises snake_case/kebab-case/camelCase and locale-aware separators.
- `ColumnSelectionTests.VisibleColumnTracking` – exercises Alt+drag and `columnSelect{Left,Right,Up,Down}` flows over tabs, injected text, and varying indentation to confirm leftover column bookkeeping.
- `SnippetControllerTests.PlaceholderNavigation` – validates snippet insertion/merge, tabstop navigation, choice completion integration, undo-stop behavior, and MarkdownRenderer placeholder markers.
- `MarkdownRendererTests.MultiCursorAndSnippetOwners` – ensures DocUI text output renders multiple cursors/selections/snippet placeholders simultaneously and respects owner filters.

## Blockers / Dependencies / Clarifications
- `TextModel` must expose the same cursor-facing helpers TS relies on (line min/max, indentation columns, normalization, injected-text aware coordinates) before Porter can wire ColumnSelection/MoveOperations.
- Need a `WordCharacterClassifier` + locale bridge: confirm whether `PieceTree.TextBuffer.Core` should host the class or reuse `SearchParams` infrastructure; Planner/Porter to align on where to store separator tables and `Intl.Segmenter` fallbacks.
- Snippet controller requires command routing & context keys (`inSnippetMode`, `hasNextTabstop`). Clarify with Porter-CS whether these live in DocUI host or inside the TextBuffer assembly to keep DocUI deterministic.
- QA will need sample TS fixtures (e.g., `cursorWord.test.ts`, `snippetController2.test.ts`) to mirror; best to schedule cross-team review before implementing tests so naming/coverage expectations stay aligned.

## Notes for Porter-CS / QA
- Porter-CS should sequence work as: (1) land cursor infrastructure + model helpers, (2) port word & column selection APIs, (3) introduce snippet session/controller plus MarkdownRenderer owner updates. Each stage should update `docs/reports/migration-log.md` and `agent-team/indexes/README.md`.
- QA-Automation needs to plan new suites under `src/PieceTree.TextBuffer.Tests/Cursor/` and `.../Snippets/` once stubs exist; see Validation Hooks for suggested class names.
- Info-Indexer/DocMaintainer will want DocUI samples once MarkdownRenderer can emit multiple cursors/snippet placeholders; capture before/after snippets to unblock AA4-008 planning.
